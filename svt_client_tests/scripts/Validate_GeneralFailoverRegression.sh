#!/bin/bash
#
# script to check GeneralFailoverRegression files
#
# $1 is either STD|HAP
#
# $2 is file of testcase stdout
#
sleep 1s

#
# Below is file generated by GeneralFailoverRegression
#
CHECKFILE=FillStoreisFailover

if [ "$#" -ne "2" ]; then
        echo "args required"
        echo "Syntax is [STD|HAP] [filename of testcase stdout]"
        exit 1
fi
if [[ "$1" != "STD" && "$1" != "HAP" ]]; then
        echo "Syntax is [STD|HAP] [filename of testcase stdout]"
        exit 1
fi
if [ ! -f $2 ]; then
        echo "File $2 does not exist"
        exit 1
fi

FILEOUT=$2
TESTTYPE=$1
if [ "`cat $FILEOUT |grep -e "at com." -e "at java."`" ] || [ "`cat $FILEOUT |grep -e "JVMDUMP"`" ]; then
        echo "Found exception in stdout"
        exit 1
fi

#
# Here add specific verification for this testcase
#

#
# GeneralFailoverRegression creates 'FillStoreisFailover' file with messages 
# indicating status of creating/sending messages and when it forces a failover.
#
# Within stdout the messages pretain to when failover occurs and how
# appliances react. Java exceptions can occur within stdout but we should had
# check excpetions from above already.
#
# We should check for hangs after a failover attempt. The FillStoreisFailover
# should show lots of memory exceptions after failover attempt
#
# The message used when failover occurs:
# 'Mixed failover. Will be using a forced stop=true' within 'FillStoreisFailover'
# And 'Going to stop the server now.' within stdout
# Lets look for last one and make sure it successfully failed over. If 
# no matching success failover message appears then its a failure, even
# if the testcase stops in middle of failover
#
# NOTE: the testcase will sleep for 6mins after standby becomes primary, 
# and before it starts old primary to become standby. Therefore, the
# deltas found in stdout will not include the 6mins. However, the total
# delta (from stopping primary to when old primary becomes standby)
#

#
# Lets look for last failover within stdout file
# and see if we recovered successfully
# use 'tac' to reverse output of file and grep for first (really last) time
# failover occured
#
LASTFAILOVER_TIME=`tac $FILEOUT |grep -m1 "Going to stop the server now. If HA configuration this" | gawk {'print $1" "$2'}`

echo "Last failover occured: $LASTFAILOVER_TIME"

declare -i LASTFAILOVER_UNIXTIME=0
#
#Convert to unix seconds time for comparison
#
LASTFAILOVER_UNIXTIME=$(date --date="${LASTFAILOVER_TIME}" +%s)

#
#
# Read in each line of stdout to calculate how long it takes
# standby to become primary
#
declare -i STOP_UNIXTIME
declare -a STANDBY_PROMOTED
declare -i START_UNIXTIME
declare -a PRIMARY_DEMOTED
while read -r DATE TIME LOGMSG; do
	TIMESTAMP="${DATE} ${TIME}"

	if [[ $LOGMSG == *"We are going to stop "* ]]; then
		echo "found primary stop:${TIMESTAMP}"
		MSG_UNIXTIME=$(date --date="${TIMESTAMP}" +%s)
		STOP_UNIXTIME=$MSG_UNIXTIME
	fi

	if [[ $LOGMSG == *"standby is running as primary=true"* ]]; then
		echo "found success protomotion:${TIMESTAMP}"
		MSG_UNIXTIME=$(date --date="${TIMESTAMP}" +%s)
		STANDBY_PROMOTED_DELTA=($(( MSG_UNIXTIME-STOP_UNIXTIME )))
		#echo "DEBUG:standby_protomoted_delta: ${STANDBY_PROMOTED_DELTA}"
		STANDBY_PROMOTED+=($(( MSG_UNIXTIME-STOP_UNIXTIME )))
	fi	
		
	if [[ $LOGMSG == *"Attempting to start the standby"* ]]; then
		echo "found start new standby:${TIMESTAMP}"
		MSG_UNIXTIME=$(date --date="${TIMESTAMP}" +%s)
		START_UNIXTIME=$MSG_UNIXTIME
	fi

	if [[ $LOGMSG == *"Standby is back up=true"* ]]; then
		echo "found new standby back up:${TIMESTAMP}"
		MSG_UNIXTIME=$(date --date="${TIMESTAMP}" +%s)
		PRIMARY_DEMOTED_DELTA=($(( MSG_UNIXTIME-START_UNIXTIME )))
		#echo "DEBUG:primary_demoted_delta: ${PRIMARY_DEMOTED_DELTA}"
		PRIMARY_DEMOTED+=($(( MSG_UNIXTIME-START_UNIXTIME )))
	fi

done < "$FILEOUT"

#
# Read in each line and process file for messages after last failover
#
declare -i NUM_EXCEPTION=0
declare -i NUM_SUCCESSMSG=0
declare -i NUM_FAILOVERS=0
declare -i MSG_UNIXTIME=0
declare -i FAILOVER_START=0
declare -i FAILOVER_DELTA=0
declare -i FOUND_STOP=0

while read -r DATE TIME LOGMSG; do
	#
	# compare timestamp and only process after last failover
	#
	# DEBUG echo "$LINE |gawk {'print $1" "$2'}"
	TIMESTAMP="${DATE} ${TIME}"
	MSG_UNIXTIME=$(date --date="${TIMESTAMP}" +%s)
	# DEBUG echo "processing message with timesteamp:$MSG_UNIXTIME"
 
	if (( $LASTFAILOVER_UNIXTIME <= $MSG_UNIXTIME )); then
		echo "line after lastfailover:$LOGMSG"
		#
		# Only look for 'A exception occured - checking memory'
		# and its pair 'An general exception occured'
		# These paired messages doesnt mean a failure of testcase
		# only that testcase is waiting for failover to succeed
		#
		if [[ $LOGMSG == *"A exception occured - checking memory"* || $LOGMSG == *"An general exception occured"* ]]; then
			#
			# increment NUM_EXCEPTION since we found
			# point in messages where testcase is waiting
			# for result of failover
			#
			NUM_EXCEPTION=$((++NUM_EXCEPTION))
		fi

		#
		# if message 'All consumers and producers set up' is seen then
		# the failover should have succeeded. Base on observations
		# this message appears ~8sec after last 'An general exception...
		#
		if [[ $LOGMSG == *"All consumers and producers set up"* ]]; then
			#
			# Found success message after failover. 
			#
			NUM_SUCCESSMSG=1
		fi
	fi

	#
	# Lets keep track of failover deltas
	#
	if [[ $LOGMSG == *"All consumers and producers set up"*  ]] && [ $FOUND_STOP == 1 ]; then
		#echo "DEBUG NUM_FAILOVER=${NUM_FAILOVERS}"
		NUM_FAILOVERS=$((++NUM_FAILOVERS))
		echo "Number of failovers:$NUM_FAILOVERS"	
		#Ignore first message at startup	
		if (( $NUM_FAILOVERS >= 1 )); then
			FAILOVER_DELTA=$(( MSG_UNIXTIME-FAILOVER_START ))
			echo "Failover end time:$TIMESTAMP"
			echo "Standby to primary delta:${STANDBY_PROMOTED[$NUM_FAILOVERS-1]}"
			echo "Primary to standby delta:${PRIMARY_DEMOTED[$NUM_FAILOVERS-1]}"
			echo "Total completed failover delta:$FAILOVER_DELTA"
		fi
		#reset found stop
		FOUND_STOP=0
	fi
	if [[ $LOGMSG == *"Mixed failover. Will be using a forced stop"* ]]; then
		FAILOVER_START=$MSG_UNIXTIME
		FOUND_STOP=1
		#DEBUG echo "Failover start:$FAILOVER_START"
	fi

done < "$CHECKFILE"


#
# Base on successful case failover can take upto ~20mins for full
# successful failover
# Base on stdout seems ~14mins of the 20mins is to recognize server stopped.
# The case of 20min for full failover is worst observed so far. Some do take
# <~10mins for full successfailover
# 

#
# if we did not find a matching success for when failover started, appliances
# may be in a hang/maintence state which is a failure
#
if [ $NUM_SUCCESSMSG == 0 ]; then
	echo "no matching successful message of 'All consumers and producers set up'"
	echo "there are $NUM_EXCEPTION memory exceptions after last failover attempt"
	let TOTALMEM_TIME=$NUM_EXCEPTION*5
	echo "total time of memory exceptions observed:$TOTALMEM_TIME"
	exit 1
fi

# We are at end of verification. If we havent exited already then
# we are successful
echo "GeneralFailoverRegression Success"
exit 0
